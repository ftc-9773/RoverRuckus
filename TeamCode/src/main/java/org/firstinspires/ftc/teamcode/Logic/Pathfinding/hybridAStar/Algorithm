1: procedure PLANPATH (map, valid_motion_primitives, CurRobotPos, CurRobotHeading, Goal)
2: ns ← (CurdiscreteRobotPos,CurdiscreteRobotHeading, CurRobotPos, 0, h(CurRobotPos, Goal), -)
3: O ← {ns}
4: C ← ∅
5: while O 6= ∅ do
6: n ← node with minimum f value in O
7: O ← O \ {n}
8: C ← C ∪ {n}
9: if nx ∈ Goal then
10: return reconstructed path starting at n
11: else
12: UPDATENEIGHBORS(m, valid_motion_primitives, O, C, n)
13: end if
14: end while
15: return no path found
16: end procedure


17: procedure UPDATENEIGHBORS(m, valid_motion_primitives, O, C, n)
18: for all δ do
19: n0 ← succeeding state of n using valid_motion_primitives(nθ, δ)
20: if n0 ∈/ C then
21: if mo(n0x˜) = obstacle then
22: C ← C ∪ {n0}
23: else if ∃n ∈ O : nx˜ = n0x˜then
24: compute new costs g0
25: if g0 < g value of existing node in O then
26: replace existing node in O with n0
27: end if
28: else
29: O ← O ∪ {n0}
30: end if
31: end if
32: end for
33: end procedure
